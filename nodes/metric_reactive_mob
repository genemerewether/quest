#! /usr/bin/env python

import rospy
import actionlib
import sys
import os
import future
from transitions.extensions import HierarchicalGraphMachine as Machine
from transitions.extensions.states import add_state_features, Tags, Timeout
import logging
from time import sleep

from threading import Lock

import tf

from fprime_msgs.msg import RunSeqAction, RunSeqGoal
from mav_msgs.msg import BoolStamped, AttitudeRateThrust, FlatOutput
from sensor_msgs.msg import Joy

states = ['init',
          'idle',
          'reboot',
          {'name': 'metric', 'children': ['takeoffPrep', 'takeoff', 'hover', 'plan', 'land', 'postLand']},
          {'name': 'reactive', 'children': ['takeoffPrep', 'takeoff', 'hop', 'plan', 'land', 'postLand']}]

timeouts = { 'init': (60.0, 'doReboot'),
             'metric_takeoffPrep': (20.0, 'metricTakeoffPrepAbort'),
             'metric_takeoff': (1.0, 'metricTakeoffAbort'),
             'reactive_takeoffPrep': (20.0, 'reactiveTakeoffPrepAbort'),
             'reactive_takeoff': (1.0, 'reactiveTakeoffPrepAbort')}

valid_metric_to_reactive_inflight_states = ['metric_takeoff', 'metric_land', 'metric_hover', 'metric_plan']
valid_reactive_to_metric_inflight_states = ['reactive_hop', 'reactive_plan']

transitions = [
    # switching and recovery behaviors
    { 'trigger': 'toReactivePlanInflight',
      'source': valid_metric_to_reactive_inflight_states,
      'dest': 'reactive_plan'
    },
    { 'trigger': 'toReactiveLandInflight',
      'source': valid_metric_to_reactive_inflight_states,
      'dest': 'reactive_land'
    },
    { 'trigger': 'toMetricHoverInflight',
      'source': valid_reactive_to_metric_inflight_states,
      'dest': 'metric_hover',
      'conditions': ['is_metric_state_estimation_ok',
                     'is_metric_control_error_ok']
    },
    { 'trigger': 'metricTakeoffPrepAbort',
      'source': 'metric_takeoffPrep',
      'dest': 'metric_postLand'
    },
    { 'trigger': 'reactiveTakeoffPrepAbort',
      'source': 'reactive_takeoffPrep',
      'dest': 'reactive_postLand'
    },
    { 'trigger': 'metricTakeoffAbort',
      'source': 'metric_takeoff',
      'dest': 'metric_land'
    },
    { 'trigger': 'reactiveTakeoffAbort',
      'source': 'reactive_takeoff',
      'dest': 'reactive_land'
    },

    # init
    { 'trigger': 'completeInit',
      'source': 'init',
      'dest': 'idle'
    },
    { 'trigger': 'doIdle',
      'source': ['metric_postLand', 'reactive_postLand'],
      'dest': 'idle'
    },

    # metric mode nominal
    { 'trigger': 'metricTakeoffPrep',
      'source': 'idle',
      'dest': 'metric_takeoffPrep',
      'conditions': ['is_ok_to_fly']
    },
    { 'trigger': 'metricTakeoff',
      'source': 'metric_takeoffPrep',
      'dest': 'metric_takeoff',
      'conditions': ['is_metric_state_estimation_ok']
    },
    { 'trigger': 'metricHover',
      'source': 'metric_takeoff',
      'dest': 'metric_hover',
      'conditions': ['is_clear_of_ground']
    },
    { 'trigger': 'metricPlan',
      'source': 'metric_hover',
      'dest': 'metric_plan'
    },

    { 'trigger': 'metricLand',
      'source': ['metric_hover', 'metric_plan'],
      'dest': 'metric_land',
    },
    { 'trigger': 'metricPostLand',
      'source': 'metric_land',
      'dest': 'metric_postLand',
    }
]
          
@add_state_features(Tags, Timeout)
class MetricReactiveMob(Machine):
    def loop_callback(self, event):
        with self.lock:
            #rospy.loginfo('state {}, elapsed {}'.format(self.state,
            #                                            str(event.current_real.to_sec() - self.stateStartTime)))

            if abs(event.current_real.to_sec() - event.current_expected.to_sec()) > 0.1:
                rospy.logwarn('loop slip time {}, exp. time {}'.format(str(event.current_real),
                                                                       str(event.current_expected)))

            if self.state in timeouts:
                if event.current_expected.to_sec() > self.stateStartTime + timeouts[self.state][0]:
                    rospy.logwarn('timeout in state {}'.format(self.state))
                    f = getattr(self, timeouts[self.state][1])
                    f()
                    
            odom_trans = None
            odom_rot = None

            ctrlErr_trans = None
            ctrlErr_rot = None
            try:
                (odom_trans, odom_rot) = self.trListener.lookupTransform('quest-base-link', 'world', rospy.Time(0))
                (ctrlErr_trans, ctrlErr_rot) = self.trListener.lookupTransform('quest-base-link', 'quest-unknown', rospy.Time(0))
            except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                if not self.state in ['idle', 'init', 'reboot']:
                    rospy.logwarn('exception looking up tf')
                if 'metric_takeoff' == self.state:
                    self.metricTakeoffAbort()
                    return
                elif 'metric_hover' == self.state or 'metric_plan' == self.state:
                    self.metricLand()
                    return

            if 'metric_takeoff' == self.state:
                if odom_trans is not None and odom_trans[2] >= self.takeoff_height:
                    rospy.logwarn('reached takeoff height')
                    self.metricHover()
            elif 'metric_land' == self.state:
                # if l.t. land height or control error increasing, switch to postland
                if odom_trans is not None and odom_trans[2] <= self.land_height:
                    rospy.logwarn('reached land height')
                    self.metricPostLand()
            else:
                pass

    def done_callback(self, ts, r):
        with self.lock:
            self.advance_action_queue()
            
    def append_action(self, pathToSeq):
        goal = RunSeqGoal()
        goal.pathToSeq.data = pathToSeq
        self.action_queue.append(((self.client, 'send_goal'), # class member function
                                  None, # class member function instead of normal function
                                  [goal], # args
                                  { 'done_cb': self.done_callback})) # kwargs
        
    def advance_action_queue(self):
        rospy.logdebug('advance action queue in state {}'.format(self.state))
        if not self.action_queue:
            rospy.logwarn('action queue empty in state {}'.format(self.state))
            return

        a = self.action_queue.pop(0)
            
        if a[0] is not None and a[1] is not None:
            raise ValueError('both class member function and non-class-member function given; 0th and 1st list positions')
        if a[0] is None and a[1] is None:
            raise ValueError('neither class member function nor non-class-member function given; 0th and 1st list positions')

        if a[0] is not None:
            rospy.logdebug('advance action queue calling {}'.format(a[0]))
            f = getattr(a[0][0], a[0][1])
        else:
            rospy.logdebug('advance action queue calling {}'.format(a[1]))
            f = a[1]

        if a[2] is None and a[3] is None:
            f()
        elif a[2] is not None and a[3] is None:
            f(*a[2])
        elif a[2] is None and a[3] is not None:
            f(**a[3])
        else:
            f(*a[2], **a[3])
    
    def initRos(self):
        self.client = actionlib.SimpleActionClient('ROSSEQ', RunSeqAction)
        self.client.wait_for_server()

        self.att_rate_thrust_pub = rospy.Publisher('attitude_rate_thrust_setpoint', AttitudeRateThrust, queue_size=1)
        self.flysafe_pub = rospy.Publisher('flysafe', BoolStamped, queue_size=1)

        self.stateStartTime = rospy.get_time()

        self.trListener = tf.TransformListener()
        
        # must be last
        self.loopDriver = rospy.Timer(rospy.Duration(0.01), self.loop_callback)

    def is_ok_to_fly(self):
        # max tilt for takeoff
        # motor sweeps - check commanded vs. actual
        # battery voltage / elapsed flight time / elapsed time
        # system health
        return True
    
    def is_metric_control_error_ok(self):
        return True
    
    def is_metric_state_estimation_ok(self):
        return True
    
    def is_clear_of_ground(self):
        return True

    def on_enter_metric_takeoffPrep(self):
        self.append_action('/seq/negthrust.bin')
        self.append_action('/seq/attrate.bin')
        self.append_action('/seq/vislam_on.bin')
        self.append_action('/seq/dfs_on.bin')
        self.append_action('/seq/arm.bin')

        # todo (mereweth) - enough time for health checks?
        self.action_queue.append(((self, 'metricTakeoff'), # class member function
                                  None, # class member function instead of normal function
                                  None, # no args
                                  None)) # no kwargs

    def on_enter_metric_takeoff(self):
        self.append_action('/seq/att_thrust.bin')

        a = AttitudeRateThrust()
        a.header.stamp = rospy.Time.now()
        a.attitude.w = 1
        a.attitude.x = 0
        a.attitude.y = 0
        a.attitude.z = 0
        a.thrust.z = self.mass * 1.01 * 9.81
        # todo (mereweth) - stamp will be old
        self.action_queue.append(((self.att_rate_thrust_pub, 'publish'), # class member function
                                  None, # class member function instead of normal function
                                  [a], # args
                                  None)) # no kwargs

    def on_enter_metric_land(self):
        a = AttitudeRateThrust()
        a.header.stamp = rospy.Time.now()
        a.attitude.w = 1
        a.attitude.x = 0
        a.attitude.y = 0
        a.attitude.z = 0
        a.thrust.z = self.mass * 0.90 * 9.81
        # todo (mereweth) - stamp will be old
        self.action_queue.append(((self.att_rate_thrust_pub, 'publish'), # class member function
                                  None, # class member function instead of normal function
                                  [a], # args
                                  None)) # no kwargs
        
    def on_enter_metric_postLand(self):
        self.append_action('/seq/disarm.bin')
        self.append_action('/seq/ctrldisable.bin')
        self.append_action('/seq/vislam_off.bin')
        self.append_action('/seq/dfs_off.bin')

        self.action_queue.append(((self, 'doIdle'), # class member function
                                  None, # class member function instead of normal function
                                  None, # no args
                                  None)) # no kwargs

    def terminate_actions(self):
        self.action_queue = []
        self.client.cancel_all_goals()
        
    def reset_state_start_time(self):
        if not rospy.is_shutdown():
            self.stateStartTime = rospy.get_time()
    
    def __init__(self):
        Machine.__init__(self, states=states, transitions=transitions, initial='init',
                         before_state_change=['terminate_actions'],
                         after_state_change=['reset_state_start_time', 'advance_action_queue'],
                         show_conditions=False,
                         show_auto_transitions=False,
                         show_state_attributes=False)
        # todo params
        self.mass = 1.56779
        self.takeoff_height = 10.0
        self.land_height = 0.2
        
        self.stateStartTime = 0

        self.action_queue = []
        self.lock = Lock()

def dump():
    m = MetricReactiveMob()
    m.get_graph().draw('metric_reactive_mob_state_diagram.png', prog='dot')

def main():
    rospy.init_node('metric_reactive_mob', log_level=rospy.WARN)

    logging.basicConfig(level=logging.DEBUG)
    logging.getLogger('transitions').setLevel(logging.DEBUG)
    
    m = MetricReactiveMob()
    m.initRos()
    
    m.completeInit()
    # takes us all the way to takeoff
    # checks in loop take us to hover
    m.metricTakeoffPrep()
    
    rospy.spin()

    return

if __name__ == '__main__':
    main()
