#! /usr/bin/env python

import rospy
import actionlib
import sys
import os
import future
from transitions import MachineError
from transitions.extensions import HierarchicalGraphMachine as Machine
from transitions.extensions.states import add_state_features, Tags, Timeout
import logging
from time import sleep

from threading import Lock

import tf

from fprime_msgs.msg import RunSeqAction, RunSeqGoal
from mav_msgs.msg import BoolStamped, AttitudeRateThrust, FlatOutput
from sensor_msgs.msg import Joy
from std_msgs.msg import Bool

states = ['init',
          'idle',
          'reboot',
          {'name': 'metric', 'children': ['takeoffPrep', 'takeoff', 'climb',
                                          'hover', 'plan',
                                          'descendToLand', 'land', 'postLand']},
          {'name': 'reactive', 'children': ['takeoffPrep', 'takeoff', 'hop', 'plan', 'land', 'postLand']}]

timeouts = { 'init': (60.0, 'doReboot'),
             
             'metric_takeoffPrep': (20.0, 'metricTakeoffPrepAbort'),
             'metric_takeoff': (1.0, 'metricTakeoffAbort'),
             
             'reactive_takeoffPrep': (20.0, 'reactiveTakeoffPrepAbort'),
             'reactive_takeoff': (1.0, 'reactiveTakeoffPrepAbort'),
             
             'metric_climb': (2.0, 'metricDescendToLand'),             
             'metric_descendToLand': (2.0, 'metricLand'),
             'metric_land': (1.0, 'metricPostLand'),

             'metric_hover': (10.0, 'metricDescendToLand')}

valid_metric_to_reactive_inflight_states = ['metric_takeoff', 'metric_climb',
                                            'metric_hover', 'metric_plan',
                                            'metric_descendToLand', 'metric_land']
valid_reactive_to_metric_inflight_states = ['reactive_hop', 'reactive_plan']

transitions = [
    # switching and recovery behaviors
    { 'trigger': 'toReactivePlanInflight',
      'source': valid_metric_to_reactive_inflight_states,
      'dest': 'reactive_plan'
    },
    { 'trigger': 'toReactiveLandInflight',
      'source': valid_metric_to_reactive_inflight_states,
      'dest': 'reactive_land'
    },
    { 'trigger': 'toMetricHoverInflight',
      'source': valid_reactive_to_metric_inflight_states,
      'dest': 'metric_hover',
      'conditions': ['is_metric_state_estimation_ok',
                     'is_metric_control_error_ok']
    },
    { 'trigger': 'metricTakeoffPrepAbort',
      'source': 'metric_takeoffPrep',
      'dest': 'metric_postLand'
    },
    { 'trigger': 'reactiveTakeoffPrepAbort',
      'source': 'reactive_takeoffPrep',
      'dest': 'reactive_postLand'
    },
    { 'trigger': 'metricTakeoffAbort',
      'source': 'metric_takeoff',
      'dest': 'metric_land'
    },
    { 'trigger': 'reactiveTakeoffAbort',
      'source': 'reactive_takeoff',
      'dest': 'reactive_land'
    },

    # init
    { 'trigger': 'completeInit',
      'source': 'init',
      'dest': 'idle' # todo conditions
    },
    { 'trigger': 'doIdle',
      'source': ['metric_postLand', 'reactive_postLand'],
      'dest': 'idle'
    },

    # metric mode nominal
    { 'trigger': 'metricTakeoffPrep',
      'source': 'idle',
      'dest': 'metric_takeoffPrep',
      'conditions': ['is_ok_to_fly']
    },
    { 'trigger': 'metricTakeoff',
      'source': 'metric_takeoffPrep',
      'dest': 'metric_takeoff',
      'conditions': ['is_metric_state_estimation_ok',
                     'is_takeoff_position_set']
    },
    { 'trigger': 'metricClimb',
      'source': 'metric_takeoff',
      'dest': 'metric_climb',
    },
    { 'trigger': 'metricHover',
      'source': ['metric_climb', 'metric_plan'],
      'dest': 'metric_hover',
    },
    { 'trigger': 'metricPlan',
      'source': 'metric_hover',
      'dest': 'metric_plan'
    },

    
    { 'trigger': 'metricDescendToLand',
      'source': ['metric_climb', 'metric_hover', 'metric_plan'],
      'dest': 'metric_descendToLand',
    },
    { 'trigger': 'metricLand',
      'source': 'metric_descendToLand',
      'dest': 'metric_land',
    },
    { 'trigger': 'metricPostLand',
      'source': 'metric_land',
      'dest': 'metric_postLand',
    }
]

def check_range(buttons, button_to_check):
    if buttons[button_to_check[0]] >= button_to_check[1] and buttons[button_to_check[0]] <= button_to_check[2]:
        return True
    else:
        return False
          
@add_state_features(Tags)
class MetricReactiveMob(Machine):
    def loop_callback(self, event):
        with self.lock:
            #rospy.loginfo('state {}, elapsed {}'.format(self.state,
            #                                            str(event.current_real.to_sec() - self.stateStartTime)))

            if abs(event.current_real.to_sec() - event.current_expected.to_sec()) > 0.1:
                rospy.logwarn('loop slip time {}, exp. time {}'.format(str(event.current_real),
                                                                       str(event.current_expected)))

            if self.state in timeouts:
                if event.current_expected.to_sec() > self.stateStartTime + timeouts[self.state][0]:
                    rospy.logwarn('timeout in state {}'.format(self.state))
                    f = getattr(self, timeouts[self.state][1])
                    f()
                    
            odom_trans = None
            odom_rot = None

            ctrl_err_trans = None
            ctrl_err_rot = None
            try:
                (odom_trans, odom_rot) = self.trListener.lookupTransform('world', 'quest-base-link', rospy.Time(0))
                (ctrl_err_trans, ctrl_err_rot) = self.trListener.lookupTransform('quest-unknown', 'quest-base-link', rospy.Time(0))
            except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException) as e:
                if not self.state in ['idle', 'init', 'reboot',
                                      'metric_takeoffPrep', 'metric_postLand',
                                      'reactive_takeoffPrep', 'reactive_postLand']:
                    rospy.logwarn('exception {} looking up tf'.format(str(e)))
                if 'metric_takeoff' == self.state:
                    self.metricTakeoffAbort()
                    return
                elif self.state in ['metric_climb', 'metric_hover', 'metric_plan']:
                    self.metricLand()
                    return

            if 'metric_takeoffPrep' == self.state:
                if odom_trans is not None:
                    # todo (mereweth) - average, check for outliers, health check
                    self.ground_level = odom_trans[2]
                    self.xy_init = odom_trans[0:2]
                    self.takeoff_pos_set = True
            elif 'metric_takeoff' == self.state:
                if odom_trans is not None and odom_trans[2] >= self.takeoff_height + self.ground_level:
                    rospy.loginfo('reached takeoff height')
                    self.metricClimb()
            elif 'metric_climb' == self.state:
                if odom_trans is not None and odom_trans[2] >= self.climb_height + self.ground_level:
                    rospy.loginfo('reached climb height')
                    self.metricHover()
            elif 'metric_descendToLand' == self.state:
                # if l.t. land height or control error increasing, switch to postland
                if odom_trans is not None and odom_trans[2] <= self.descend_to_land_height + self.ground_level:
                    rospy.loginfo('reached descend_to_land height')
                    self.metricLand()
            elif 'metric_land' == self.state:
                # todo use some other metric for landing
                if odom_trans is not None and odom_trans[2] <= self.land_height + self.ground_level:
                    rospy.loginfo('reached land height')
                    self.metricPostLand()
            else:
                pass

    def done_callback(self, ts, r):
        with self.lock:
            self.advance_action_queue()
            
    def append_action(self, pathToSeq):
        goal = RunSeqGoal()
        goal.pathToSeq.data = pathToSeq
        self.action_queue.append(((self.client, 'send_goal'), # class member function
                                  None, # class member function instead of normal function
                                  [goal], # args
                                  { 'done_cb': self.done_callback}, # kwargs
                                  True)) # callback expected
        
    def advance_action_queue(self):
        rospy.logdebug('advance action queue in state {}'.format(self.state))
        if not self.action_queue:
            rospy.logwarn('action queue empty in state {}'.format(self.state))
            return

        a = self.action_queue.pop(0)
            
        if a[0] is not None and a[1] is not None:
            raise ValueError('both class member function and non-class-member function given; 0th and 1st list positions')
        if a[0] is None and a[1] is None:
            raise ValueError('neither class member function nor non-class-member function given; 0th and 1st list positions')

        if a[0] is not None:
            rospy.logdebug('advance action queue calling {}'.format(a[0]))
            f = getattr(a[0][0], a[0][1])
        else:
            rospy.logdebug('advance action queue calling {}'.format(a[1]))
            f = a[1]

        if a[2] is None and a[3] is None:
            f()
        elif a[2] is not None and a[3] is None:
            f(*a[2])
        elif a[2] is None and a[3] is not None:
            f(**a[3])
        else:
            f(*a[2], **a[3])

        if not a[4]: # no callback coming, so trigger the next action ourselves
            self.advance_action_queue()
            
    def joy_callback(self, joy):
        # todo (mereweth) - check header
        with self.lock:
            if self.joyLockout:
                return
            
            f = BoolStamped()
            f.header.stamp = rospy.Time.now()
            if check_range(joy.buttons, self.flysafe_button):
                f.data = Bool(True)
            else:
                f.data = Bool(False)
            self.flysafe_pub.publish(f)
                
            if check_range(joy.buttons, self.takeoff_button):
                try:
                    self.metricTakeoffPrep()
                except MachineError as e:
                    pass
                
    def initRos(self):
        self.client = actionlib.SimpleActionClient('ROSSEQ', RunSeqAction)
        self.client.wait_for_server()

        self.att_rate_thrust_pub = rospy.Publisher('attitude_rate_thrust_setpoint', AttitudeRateThrust, queue_size=1)
        self.flat_output_pub = rospy.Publisher('flat_output_setpoint', FlatOutput, queue_size=1)
        self.flysafe_pub = rospy.Publisher('flysafe', BoolStamped, queue_size=1)
        self.joy_sub = rospy.Subscriber('joy', Joy, self.joy_callback)
        
        self.stateStartTime = rospy.get_time()

        self.trListener = tf.TransformListener()
        
        # must be last
        self.loopDriver = rospy.Timer(rospy.Duration(0.1), self.loop_callback)

    def is_ok_to_fly(self):
        # max tilt for takeoff
        # motor sweeps - check commanded vs. actual
        # battery voltage / elapsed flight time / elapsed time
        # system health
        return True
    
    def is_takeoff_position_set(self):
        return self.takeoff_pos_set
    
    def is_metric_control_error_ok(self):
        return True
    
    def is_metric_state_estimation_ok(self):
        return True
    
    def is_clear_of_ground(self):
        return True

    def on_enter_metric_takeoffPrep(self):
        self.append_action('/seq/negthrust.bin')
        self.append_action('/seq/attrate.bin')
        self.append_action('/seq/vislam_on.bin')
        self.append_action('/seq/dfs_on.bin')
        self.append_action('/seq/arm.bin')

        # todo (mereweth) - enough time for health checks?
        # todo (mereweth) - estimation drift on spinup?
        self.action_queue.append(((self, 'metricTakeoff'), # class member function
                                  None, # class member function instead of normal function
                                  None, # no args
                                  None, # no kwargs
                                  True)) # no callback, but don't need one

    def on_enter_metric_takeoff(self):
        # todo (mereweth) - get current yaw or use rp_yawrate mode
        self.append_action('/seq/att_thrust.bin')

        a = AttitudeRateThrust()
        a.header.stamp = rospy.Time.now()
        a.attitude.w = 1
        a.attitude.x = 0
        a.attitude.y = 0
        a.attitude.z = 0
        a.thrust.z = self.mass * self.takeoff_thrust_factor * 9.81
        # todo (mereweth) - stamp will be old
        self.action_queue.append(((self.att_rate_thrust_pub, 'publish'), # class member function
                                  None, # class member function instead of normal function
                                  [a], # args
                                  None, # no kwargs
                                  True)) # no callback, but don't need one
        
    def on_enter_metric_climb(self):
        # todo (mereweth) - profile from current

        f = FlatOutput()
        f.header.stamp = rospy.Time.now()
        f.velocity.z = self.climb_descend_speed
        f.yaw = 0.0
        # todo (mereweth) - stamp will be old
        self.action_queue.append(((self.flat_output_pub, 'publish'), # class member function
                                  None, # class member function instead of normal function
                                  [f], # args
                                  None, # no kwargs
                                  False)) # no callback, need trigger
        
        self.append_action('/seq/linvel.bin')
        
    def on_enter_metric_hover(self):
        # todo (mereweth) - profile from current

        f = FlatOutput()
        f.header.stamp = rospy.Time.now()
        f.position.x = self.xy_init[0]
        f.position.y = self.xy_init[1]
        f.position.z = self.hover_height + self.ground_level
        # todo (mereweth) - stamp will be old
        self.action_queue.append(((self.flat_output_pub, 'publish'), # class member function
                                  None, # class member function instead of normal function
                                  [f], # args
                                  None, # no kwargs
                                  False)) # no callback, need trigger
        
        self.append_action('/seq/flatoutput.bin')
        
    def on_enter_metric_descendToLand(self):
        # todo (mereweth) - profile from current

        f = FlatOutput()
        f.header.stamp = rospy.Time.now()
        f.velocity.z = -self.climb_descend_speed
        f.yaw = 0.0
        # todo (mereweth) - stamp will be old
        self.action_queue.append(((self.flat_output_pub, 'publish'), # class member function
                                  None, # class member function instead of normal function
                                  [f], # args
                                  None, # no kwargs
                                  False)) # no callback, need trigger
        
        self.append_action('/seq/linvel.bin')
        
    def on_enter_metric_land(self):
        # todo (mereweth) - get current yaw or use rp_yawrate mode
        a = AttitudeRateThrust()
        a.header.stamp = rospy.Time.now()
        a.attitude.w = 1
        a.attitude.x = 0
        a.attitude.y = 0
        a.attitude.z = 0
        a.thrust.z = self.mass * self.land_thrust_factor * 9.81
        # todo (mereweth) - stamp will be old
        self.action_queue.append(((self.att_rate_thrust_pub, 'publish'), # class member function
                                  None, # class member function instead of normal function
                                  [a], # args
                                  None, # no kwargs
                                  True)) # no callback, but don't need one
        
    def on_enter_metric_postLand(self):
        self.append_action('/seq/disarm.bin')
        self.append_action('/seq/ctrldisable.bin')
        self.append_action('/seq/vislam_off.bin')
        self.append_action('/seq/dfs_off.bin')

        self.action_queue.append(((self, 'doIdle'), # class member function
                                  None, # class member function instead of normal function
                                  None, # no args
                                  None, # no kwargs
                                  True)) # no callback, but don't need one

    def on_enter_idle(self):
        self.takeoff_pos_set = False
        
    def terminate_actions(self):
        if self.action_queue:
            rospy.logwarn('action queue not empty leaving state {}'.format(self.state))
        self.action_queue = []
        self.client.cancel_all_goals()
        
    def reset_state_start_time(self):
        if not rospy.is_shutdown():
            self.stateStartTime = rospy.get_time()

    def log_before_state_change(self):
        rospy.loginfo('before leaving state {} at time {}'.format(self.state,
                                                                  str(rospy.get_time())))

    def log_after_state_change(self):
        rospy.loginfo('after entering state {} at time {}'.format(self.state,
                                                                  str(rospy.get_time())))
                      
    def __init__(self):
        Machine.__init__(self, states=states, transitions=transitions, initial='init',
                         before_state_change=['terminate_actions',
                                              'log_before_state_change'],
                         after_state_change=['reset_state_start_time',
                                             'advance_action_queue',
                                             'log_after_state_change'],
                         show_conditions=False,
                         show_auto_transitions=False,
                         show_state_attributes=False)
        # todo params
        self.mass = 1.56779
        
        self.takeoff_thrust_factor = 1.20
        self.land_thrust_factor = 0.80
        
        self.takeoff_height = 0.3
        self.climb_height = 0.75
        self.hover_height = 1.0
        self.descend_to_land_height = 0.3
        self.climb_descend_speed = 0.5

        # button index, low val, high val
        self.flysafe_button = (4, 0.95, 1.05)
        self.takeoff_button = (0, 0.95, 1.05)
        self.joyLockout = False

        # todo get rid of land_height
        self.land_height = 0.15

        self.ground_level = 0.0
        self.xy_init = [0.0, 0.0]
        self.takeoff_pos_set = False
        
        self.stateStartTime = 0.0

        self.action_queue = []
        self.lock = Lock()

def dump():
    m = MetricReactiveMob()
    m.get_graph().draw('metric_reactive_mob_state_diagram.png', prog='dot')

def main():
    rospy.init_node('metric_reactive_mob', log_level=rospy.INFO)

    logging.basicConfig(level=logging.DEBUG)
    logging.getLogger('transitions').setLevel(logging.DEBUG)
    
    m = MetricReactiveMob()
    m.initRos()
    
    m.completeInit()
    
    rospy.spin()

    return

if __name__ == '__main__':
    main()
